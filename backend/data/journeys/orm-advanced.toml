title = "Advanced Features"
order = 1

[[chapters]]
title = "Annotation & Aggregation"
content = """from django.db import models
from django.db.models import Count, Avg, Sum, Max, Min, F, Q, Case, When
from django.utils import timezone

class Author(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField(unique=True)

    def __str__(self):
        return self.name

class Category(models.Model):
    name = models.CharField(max_length=50)

    def __str__(self):
        return self.name

class Post(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='posts')
    category = models.ForeignKey(Category, on_delete=models.CASCADE, related_name='posts')
    word_count = models.PositiveIntegerField(default=0)
    view_count = models.PositiveIntegerField(default=0)
    published = models.BooleanField(default=False)
    created_at = models.DateTimeField(default=timezone.now)

    def __str__(self):
        return self.title

def run():
    # Create test data
    author1 = Author.objects.create(name='Alice Writer', email='alice@example.com')
    author2 = Author.objects.create(name='Bob Blogger', email='bob@example.com')

    tech_cat = Category.objects.create(name='Technology')
    life_cat = Category.objects.create(name='Lifestyle')

    Post.objects.bulk_create([
        Post(title='Django Tips', content='Content', author=author1, category=tech_cat, word_count=500, view_count=100, published=True),
        Post(title='Python Tricks', content='Content', author=author1, category=tech_cat, word_count=800, view_count=200, published=True),
        Post(title='Life Balance', content='Content', author=author2, category=life_cat, word_count=600, view_count=50, published=True),
        Post(title='Draft Post', content='Content', author=author2, category=tech_cat, word_count=300, view_count=0, published=False),
    ])

    # Basic aggregation
    total_posts = Post.objects.count()
    avg_word_count = Post.objects.aggregate(avg_words=Avg('word_count'))
    total_views = Post.objects.aggregate(total_views=Sum('view_count'))

    print(f'Total posts: {total_posts}')
    average_words = avg_word_count["avg_words"]
    print(f'Average word count: {average_words:.1f}')
    total_view_count = total_views["total_views"]
    print(f'Total views: {total_view_count}')

    # Annotation - add calculated fields to queryset
    authors_with_stats = Author.objects.annotate(
        post_count=Count('posts'),
        published_posts=Count('posts', filter=Q(posts__published=True)),
        total_views=Sum('posts__view_count'),
        avg_word_count=Avg('posts__word_count')
    )

    for author in authors_with_stats:
        avg_words = author.avg_word_count or 0
        print(
            f'{author.name}: {author.post_count} posts',
            f'{author.published_posts} published',
            f'{author.total_views} views',
            f'{avg_words:.1f} avg words'
        )

    # Category statistics
    category_stats = Category.objects.annotate(
        post_count=Count('posts'),
        total_words=Sum('posts__word_count'),
        popularity=Case(
            When(posts__view_count__gt=100, then=models.Value('High')),
            When(posts__view_count__gt=50, then=models.Value('Medium')),
            default=models.Value('Low'),
            output_field=models.CharField()
        )
    )

    for category in category_stats:
        print(f'Category {category.name}: {category.post_count} posts, {category.total_words} total words')"""

[[chapters]]
title = "Model Methods & Properties"
content = """from django.db import models
from django.utils import timezone
from django.urls import reverse

class Author(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField(unique=True)
    created_at = models.DateTimeField(default=timezone.now)

    def __str__(self):
        return self.name

    def get_absolute_url(self):
        return reverse('author-detail', kwargs={'pk': self.pk})

    @property
    def post_count(self):
        return self.posts.count()

    def recent_posts(self, days=7):
        cutoff = timezone.now() - timezone.timedelta(days=days)
        return self.posts.filter(created_at__gte=cutoff)

class Post(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='posts')
    created_at = models.DateTimeField(default=timezone.now)
    published = models.BooleanField(default=False)

    def __str__(self):
        return self.title

    def get_absolute_url(self):
        return reverse('post-detail', kwargs={'pk': self.pk})

    @property
    def word_count(self):
        return len(self.content.split())

    @property
    def reading_time(self):
        words_per_minute = 200
        return max(1, self.word_count // words_per_minute)

    def is_recent(self, days=7):
        cutoff = timezone.now() - timezone.timedelta(days=days)
        return self.created_at >= cutoff

def run():
    # Create test data
    author = Author.objects.create(name='Content Creator', email='creator@example.com')
    post = Post.objects.create(
        title='Long Form Article',
        content='This is a long article with many words. ' * 50,  # ~300 words
        author=author,
        published=True
    )

    # Use model methods and properties
    print(f'Author: {author.name}')
    print(f'Post count: {author.post_count}')
    print(f'Recent posts: {author.recent_posts().count()}')

    print(f'Post: {post.title}')
    print(f'Word count: {post.word_count}')
    print(f'Reading time: {post.reading_time} minute(s)')
    print(f'Is recent: {post.is_recent()}')"""

[[chapters]]
title = "Model Meta Options"
content = """from django.db import models
from django.utils import timezone

class Author(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField(unique=True)

    def __str__(self):
        return self.name

    class Meta:
        ordering = ['name']

class Post(models.Model):
    title = models.CharField(max_length=200)
    slug = models.SlugField(unique=True)
    content = models.TextField()
    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='posts')
    created_at = models.DateTimeField(default=timezone.now)
    updated_at = models.DateTimeField(auto_now=True)
    published = models.BooleanField(default=False)

    def __str__(self):
        return self.title

    class Meta:
        ordering = ['-created_at']  # Newest first
        indexes = [
            models.Index(fields=['author', 'published']),
            models.Index(fields=['created_at']),
        ]
        constraints = [
            models.UniqueConstraint(fields=['author', 'title'], name='unique_author_title')
        ]

def run():
    # Create test data
    author1 = Author.objects.create(name='Zoe Writer', email='zoe@example.com')
    author2 = Author.objects.create(name='Alice Blogger', email='alice@example.com')

    Post.objects.create(title='First Post', slug='first-post', content='Content', author=author1, published=True)
    Post.objects.create(title='Second Post', slug='second-post', content='More content', author=author2, published=True)

    # Default ordering in effect
    authors = Author.objects.all()
    print('Authors (ordered by name):')
    for author in authors:
        print(f'- {author.name}')

    posts = Post.objects.all()
    print('Posts (newest first):')
    for post in posts:
        print(f'- {post.title}')

    # Try to create duplicate title for same author (will fail due to constraint)
    try:
        Post.objects.create(title='First Post', slug='first-post-2', content='Duplicate', author=author1)
    except Exception as e:
        print(f'Constraint prevented duplicate: {type(e).__name__}')"""

[[chapters]]
title = "Constraints & Validation"
content = """from django.db import models
from django.core.validators import MinLengthValidator, EmailValidator, RegexValidator
from django.core.exceptions import ValidationError
from django.utils import timezone

class Author(models.Model):
    name = models.CharField(
        max_length=100,
        validators=[MinLengthValidator(2)]
    )
    email = models.EmailField(unique=True)
    username = models.CharField(
        max_length=50,
        unique=True,
        validators=[
            RegexValidator(
                regex=r'^[a-zA-Z0-9_]+$',
                message='Username can only contain letters, numbers, and underscores'
            )
        ]
    )

    def clean(self):
        super().clean()
        if self.name and len(self.name.split()) < 2:
            raise ValidationError({'name': 'Name must include both first and last name'})

    def __str__(self):
        return self.name

class Post(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField(validators=[MinLengthValidator(50)])
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
    word_count = models.PositiveIntegerField(default=0)
    published_at = models.DateTimeField(blank=True, null=True)

    def clean(self):
        super().clean()
        if self.content:
            calculated_word_count = len(self.content.split())
            if abs(self.word_count - calculated_word_count) > 10:
                raise ValidationError({
                    'word_count': f'Word count should be approximately {calculated_word_count}'
                })

    def save(self, *args, **kwargs):
        if self.content:
            self.word_count = len(self.content.split())
        super().save(*args, **kwargs)

    def __str__(self):
        return self.title

    class Meta:
        constraints = [
            models.CheckConstraint(
                check=models.Q(word_count__gte=0),
                name='post_word_count_positive'
            )
        ]

def run():
    print('=== Valid Object Creation ===')
    # Valid author creation
    author = Author.objects.create(
        name='John Smith',
        email='john@example.com',
        username='johnsmith123'
    )

    # Valid post creation
    post = Post.objects.create(
        title='My First Blog Post',
        content=(
            'This is a long enough blog post content with '
            'more than fifty words to satisfy the minimum '
            'length requirement for the content field '
            'validator and demonstrate proper validation.'
        ), author=author
    )

    print(f'Created author: {author.name}')
    print(f'Created post: {post.title} with {post.word_count} words')

    print('=== Testing Field Validators ===')
    # Test field validators (need to call full_clean() to trigger them)
    try:
        invalid_author = Author(name='X', email='test@example.com', username='x')
        invalid_author.full_clean()  # This triggers field validators
        invalid_author.save()
    except ValidationError as e:
        print(f'Author field validation failed: {e}')

    try:
        invalid_post = Post(title='Short', content='Too short', author=author)
        invalid_post.full_clean()  # This triggers field validators
        invalid_post.save()
    except ValidationError as e:
        print(f'Post field validation failed: {e}')

    print('=== Testing Custom clean() Method ===')
    # Test custom clean() validation
    try:
        single_name_author = Author(name='John', email='single@example.com', username='singlename')
        single_name_author.full_clean()  # This triggers custom clean() method
        single_name_author.save()
    except ValidationError as e:
        print(f'Custom validation failed: {e}')

    print('=== Testing Username Regex Validator ===')
    # Test regex validator
    try:
        bad_username_author = Author(name='Jane Doe', email='jane@example.com', username='jane.doe!')
        bad_username_author.full_clean()
        bad_username_author.save()
    except ValidationError as e:
        print(f'Username validation failed: {e}')

    print('=== Testing Database Constraints ===')
    # Test database constraint (this bypasses Django validation)
    try:
        from django.db import connection
        with connection.cursor() as cursor:
            cursor.execute(
                "INSERT INTO app_post (title, content, author_id, word_count)"
                "VALUES ('Test', 'Content', %s, %s)",
                [author.id, -5]
            )
    except Exception as e:
        print(f'Database constraint prevented negative word_count: {type(e).__name__}')

    print('=== Testing Unique Constraints ===')
    # Test unique constraint
    try:
        duplicate_email_author = Author.objects.create(
            name='Another Person',
            email='john@example.com',  # Same email as first author
            username='anotherperson'
        )
    except Exception as e:
        print(f'Unique constraint prevented duplicate email: {type(e).__name__}')

    print('=== Summary ===')
    print('1. Field validators run with full_clean(), not with create()/save()')
    print('2. Custom clean() methods also need full_clean() to be called')
    print('3. Database constraints are enforced at the database level')
    print('4. Unique constraints work automatically with create()/save()')"""


[[chapters]]
title = "Model Inheritance"
content = """from django.db import models
from django.utils import timezone

# Abstract Base Classes
class TimestampedModel(models.Model):
    created_at = models.DateTimeField(default=timezone.now)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True  # This model won't create a database table

class AuthoredModel(TimestampedModel):
    author_name = models.CharField(max_length=100)
    author_email = models.EmailField()

    class Meta:
        abstract = True

# Multi-table Inheritance
class Content(TimestampedModel):
    title = models.CharField(max_length=200)
    slug = models.SlugField(unique=True)

    def __str__(self):
        return self.title

class Post(Content):  # Inherits from Content (multi-table inheritance)
    content = models.TextField()
    view_count = models.PositiveIntegerField(default=0)
    is_published = models.BooleanField(default=False)

    def get_type(self):
        return "Blog Post"

class Video(Content):  # Also inherits from Content
    duration = models.PositiveIntegerField(help_text="Duration in seconds")
    video_url = models.URLField()
    thumbnail = models.URLField(blank=True)

    def get_type(self):
        return "Video"

# Proxy Models
class PublishedPostManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(is_published=True)

class PublishedPost(Post):
    objects = PublishedPostManager()

    class Meta:
        proxy = True  # Same database table as Post
        ordering = ['-created_at']

    def get_absolute_url(self):
        return f'/posts/{self.slug}/'

class DraftPost(Post):
    objects = models.Manager()

    class Meta:
        proxy = True

    def get_queryset(self):
        return super().get_queryset().filter(is_published=False)

# Using Abstract Base Classes
class Comment(AuthoredModel):  # Inherits created_at, updated_at, author_name, author_email
    content = models.TextField()
    post = models.ForeignKey(Post, on_delete=models.CASCADE, related_name='comments')
    is_approved = models.BooleanField(default=False)

class Review(AuthoredModel):  # Same fields as Comment but different purpose
    rating = models.IntegerField(choices=[(i, i) for i in range(1, 6)])
    content = models.TextField()
    video = models.ForeignKey(Video, on_delete=models.CASCADE, related_name='reviews')

def run():
    print('=== Multi-table Inheritance ===')
    # Create content using inherited models
    post = Post.objects.create(
        title='Django Inheritance Guide',
        slug='django-inheritance',
        content='Learning about model inheritance in Django',
        view_count=150,
        is_published=True
    )

    video = Video.objects.create(
        title='Django Video Tutorial',
        slug='django-video',
        duration=1800,  # 30 minutes
        video_url='https://example.com/video.mp4'
    )

    print(f'Created post: {post.title} (Type: {post.get_type()})')
    print(f'Created video: {video.title} (Type: {video.get_type()})')
    print(f'Post created at: {post.created_at}')
    print(f'Video created at: {video.created_at}')

    # Both inherit from Content, so we can query all content
    all_content = Content.objects.all()
    print(f'All content items: {all_content.count()}')
    for content in all_content:
        print(f'- {content.title}')

    print('=== Proxy Models ===')
    # Create a draft post
    draft = Post.objects.create(
        title='Draft Article',
        slug='draft-article',
        content='This is a draft',
        is_published=False
    )

    # Use proxy models with different managers
    print(f'All posts: {Post.objects.count()}')
    print(f'Published posts: {PublishedPost.objects.count()}')

    # Proxy models have same data but can have different methods
    published_post = PublishedPost.objects.first()
    if published_post:
        print(f'Published post URL: {published_post.get_absolute_url()}')

    print('=== Abstract Base Classes ===')
    # Create comment using inherited timestamp and author fields
    comment = Comment.objects.create(
        post=post,
        author_name='John Reader',
        author_email='john@example.com',
        content='Great explanation of inheritance!',
        is_approved=True
    )

    review = Review.objects.create(
        video=video,
        author_name='Jane Viewer',
        author_email='jane@example.com',
        content='Very helpful tutorial',
        rating=5
    )
"""

[[chapters]]
title = "Custom Managers & QuerySets"
content = """from django.db import models
from django.utils import timezone
from datetime import timedelta

class PostQuerySet(models.QuerySet):
    def published(self):
        return self.filter(status='published')

    def drafts(self):
        return self.filter(status='draft')

    def by_author(self, author):
        return self.filter(author=author)

    def recent(self, days=7):
        cutoff = timezone.now() - timedelta(days=days)
        return self.filter(created_at__gte=cutoff)

    def popular(self, min_views=100):
        return self.filter(view_count__gte=min_views)

    def with_many_comments(self, min_comments=5):
        return self.annotate(comment_count=models.Count('comments')).filter(comment_count__gte=min_comments)

class PostManager(models.Manager):
    def get_queryset(self):
        return PostQuerySet(self.model, using=self._db)

    def published(self):
        return self.get_queryset().published()

    def drafts(self):
        return self.get_queryset().drafts()

    def recent_published(self):
        return self.get_queryset().published().recent()

    def popular_published(self):
        return self.get_queryset().published().popular()

    def with_many_comments(self, min_comments=5):
        return self.get_queryset().with_many_comments(min_comments)

class PublishedPostManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(status='published')

class Author(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField(unique=True)

    def __str__(self):
        return self.name

class Post(models.Model):
    STATUS_CHOICES = [
        ('draft', 'Draft'),
        ('published', 'Published'),
        ('archived', 'Archived'),
    ]

    title = models.CharField(max_length=200)
    content = models.TextField()
    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='posts')
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='draft')
    view_count = models.PositiveIntegerField(default=0)
    created_at = models.DateTimeField(default=timezone.now)

    # Multiple managers
    objects = PostManager()  # Custom manager with custom queryset methods
    published_posts = PublishedPostManager()  # Manager that filters by default
    all_posts = models.Manager()  # Default manager for admin, etc.

    def __str__(self):
        return self.title

class Comment(models.Model):
    post = models.ForeignKey(Post, on_delete=models.CASCADE, related_name='comments')
    author_name = models.CharField(max_length=100)
    content = models.TextField()
    created_at = models.DateTimeField(default=timezone.now)

    def __str__(self):
        return f'Comment by {self.author_name}'

def run():
    # Create test data
    author = Author.objects.create(name='Blog Author', email='author@example.com')

    posts_data = [
        {'title': 'Published Popular Post', 'status': 'published', 'view_count': 150},
        {'title': 'Published Recent Post', 'status': 'published', 'view_count': 50},
        {'title': 'Draft Post', 'status': 'draft', 'view_count': 0},
        {'title': 'Old Published Post', 'status': 'published', 'view_count': 200},
    ]

    created_posts = []
    for post_data in posts_data:
        post = Post.objects.create(
            title=post_data['title'],
            content='Sample content',
            author=author,
            status=post_data['status'],
            view_count=post_data['view_count']
        )
        created_posts.append(post)

    # Make one post old
    old_post = created_posts[-1]
    old_post.created_at = timezone.now() - timedelta(days=30)
    old_post.save()

    # Add comments to one post
    popular_post = created_posts[0]
    Comment.objects.bulk_create([
        Comment(post=popular_post, author_name=f'Commenter {i}', content=f'Comment {i}')
        for i in range(6)
    ])

    print('=== Using Custom Manager Methods ===')
    print(f'All posts: {Post.objects.count()}')
    print(f'Published posts: {Post.objects.published().count()}')
    print(f'Draft posts: {Post.objects.drafts().count()}')
    print(f'Recent published: {Post.objects.recent_published().count()}')
    print(f'Popular published: {Post.objects.popular_published().count()}')

    print('=== Using Published Posts Manager ===')
    print(f'Published posts (via published_posts manager): {Post.published_posts.count()}')

    print('=== Chaining QuerySet Methods ===')
    recent_popular = Post.objects.published().recent().popular(min_views=100)
    print(f'Recent popular posts: {recent_popular.count()}')

    by_author_published = Post.objects.published().by_author(author)
    print(f'Published posts by {author.name}: {by_author_published.count()}')

    posts_with_comments = Post.objects.with_many_comments(min_comments=5)
    print(f'Posts with 5+ comments: {posts_with_comments.count()}')

    print('=== Post Titles ===')
    for post in Post.objects.published():
        print(f'- {post.title} ({post.view_count} views)')"""
