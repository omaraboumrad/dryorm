title = "Optimization Techniques"
order = 4

[[chapters]]
title = "Bulk Operations"
content = """from django.db import models

class Author(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField(unique=True)
    post_count = models.IntegerField(default=0)

class Post(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='posts')
    view_count = models.PositiveIntegerField(default=0)
    is_featured = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)

def run():

    # Bulk create - authors
    authors = Author.objects.bulk_create([
        Author(name='Author 1', email='author1@example.com'),
        Author(name='Author 2', email='author2@example.com'),
        Author(name='Author 3', email='author3@example.com'),
    ])
    print(f'Created {len(authors)} authors')

    author_objects = list(Author.objects.all())

    # Bulk create - posts
    posts = Post.objects.bulk_create([
        Post(
            title=f'Post {i+1}',
            content=f'Content for post {i+1}',
            author=author_objects[i % len(author_objects)],
            view_count=i * 10
        ) for i in range(10)
    ])
    print(f'Created {len(posts)} posts')

    # Bulk update - update multiple records in single query
    updated_count = Post.objects.filter(view_count__gte=50).update(is_featured=True)
    print(f'Updated {updated_count} posts')

    # Update with F expressions for atomic operations
    Post.objects.all().update(view_count=models.F('view_count') + 10)
    print('Incremented view_count for all posts by 10')

    # Update author post counts
    for author in Author.objects.annotate(actual_count=models.Count('posts')):
        Author.objects.filter(pk=author.pk).update(post_count=author.actual_count)

    print('Updated author post counts')

    # Bulk delete
    deleted_count = Post.objects.filter(view_count__lt=30).delete()
    print(f'Deleted {deleted_count[0]} posts with low view counts')

    # Update or create in bulk
    author, created = Author.objects.update_or_create(
        email='newauthor@example.com',
        defaults={'name': 'New Author Updated'}
    )
    print(f'Author {"created" if created else "updated"}: {author.name}')

    # Final Statistics
    authors_with_counts = Author.objects.annotate(actual_posts=models.Count('posts'))
    for author in authors_with_counts:
        print(f'{author.name}: {author.post_count} stored count, {author.actual_posts} actual posts')
"""

[[chapters]]
title = "Query Optimization"
content = """
from django.db import models
from django.utils import timezone
from django.db import connection
from contextlib import contextmanager

# -- Ignore this function - It's used for utility
@contextmanager
def count_queries(description):
    initial_count = len(connection.queries)
    yield
    final_count = len(connection.queries)
    print(f"{description}: {final_count - initial_count} queries executed")

# --

class Author(models.Model):
    name = models.CharField(max_length=100)

class Category(models.Model):
    name = models.CharField(max_length=50)

class Tag(models.Model):
    name = models.CharField(max_length=50)

class Post(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
    category = models.ForeignKey(Category, on_delete=models.CASCADE)
    tags = models.ManyToManyField(Tag)
    created_at = models.DateTimeField(auto_now_add=True)

def run():

    author = Author.objects.create(name='Tech Writer')
    category = Category.objects.create(name='Programming')
    post1 = Post.objects.create(title='Python Basics', content='Learning Python', author=author, category=category)
    post2 = Post.objects.create(title='Django Advanced', content='Advanced Django', author=author, category=category)
    post3 = Post.objects.create(title='Ruby Advanced', content='Advanced RoR', author=author, category=category)

    # Select Related Optimization

    with count_queries("author / category without optimization"):
        posts = Post.objects.all()
        for post in posts:
            # Each access triggers a separate database query
            result = f'{post.title} by {post.author.name} in {post.category.name}'

    with count_queries("author / category with select_related"):
        posts = Post.objects.select_related('author', 'category')
        for post in posts:
            # Author and category data already loaded, no additional queries
            f'{post.title} by {post.author.name} in {post.category.name}'

    # Prefetch Optimization

    tag1 = Tag.objects.create(name='python')
    tag2 = Tag.objects.create(name='django')
    tag3 = Tag.objects.create(name='oop')
    tag4 = Tag.objects.create(name='best practices')
    post1.tags.add(tag1, tag2, tag3)
    post2.tags.add(tag1, tag2, tag4)
    post3.tags.add(tag3, tag4)

    with count_queries("tags without optimization"):
        posts = Post.objects.all()

        for post in posts:
            tag_names = ', '.join(tag.name for tag in post.tags.all())
            f'{post.title} - Tags: {tag_names}'

    with count_queries("tags with prefetch_related"):
        posts = Post.objects.prefetch_related('tags')

        for post in posts:
            tag_names = ', '.join(tag.name for tag in post.tags.all())
            f'{post.title} - Tags: {tag_names}'

"""
