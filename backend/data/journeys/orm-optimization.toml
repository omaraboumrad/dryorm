title = "Optimization Techniques"
order = 4

[[chapters]]
title = "Bulk Operations"
content = """from django.db import models

class Author(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField(unique=True)
    post_count = models.IntegerField(default=0)

class Post(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='posts')
    view_count = models.PositiveIntegerField(default=0)
    is_featured = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)

def run():

    # Bulk create - authors
    authors = Author.objects.bulk_create([
        Author(name='Author 1', email='author1@example.com'),
        Author(name='Author 2', email='author2@example.com'),
        Author(name='Author 3', email='author3@example.com'),
    ])
    print(f'Created {len(authors)} authors')

    author_objects = list(Author.objects.all())

    # Bulk create - posts
    posts = Post.objects.bulk_create([
        Post(
            title=f'Post {i+1}',
            content=f'Content for post {i+1}',
            author=author_objects[i % len(author_objects)],
            view_count=i * 10
        ) for i in range(10)
    ])
    print(f'Created {len(posts)} posts')

    # Bulk update - update multiple records in single query
    updated_count = Post.objects.filter(view_count__gte=50).update(is_featured=True)
    print(f'Updated {updated_count} posts')

    # Update with F expressions for atomic operations
    Post.objects.all().update(view_count=models.F('view_count') + 10)
    print('Incremented view_count for all posts by 10')

    # Update author post counts
    for author in Author.objects.annotate(actual_count=models.Count('posts')):
        Author.objects.filter(pk=author.pk).update(post_count=author.actual_count)

    print('Updated author post counts')

    # Bulk delete
    print('=== Bulk Delete ===')
    deleted_count = Post.objects.filter(view_count__lt=30).delete()
    print(f'Deleted {deleted_count[0]} posts with low view counts')

    # Update or create in bulk
    print('=== Update or Create ===')
    author, created = Author.objects.update_or_create(
        email='newauthor@example.com',
        defaults={'name': 'New Author Updated'}
    )
    print(f'Author {"created" if created else "updated"}: {author.name}')

    # Display final statistics
    print('=== Final Statistics ===')
    authors_with_counts = Author.objects.annotate(actual_posts=models.Count('posts'))
    for author in authors_with_counts:
        print(f'{author.name}: {author.post_count} stored count, {author.actual_posts} actual posts')
"""

[[chapters]]
title = "Query Optimization"
content = """from django.db import models
from django.utils import timezone

class Author(models.Model):
    name = models.CharField(max_length=100)

class Category(models.Model):
    name = models.CharField(max_length=50)

class Tag(models.Model):
    name = models.CharField(max_length=50)

class Post(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
    category = models.ForeignKey(Category, on_delete=models.CASCADE)
    tags = models.ManyToManyField(Tag)
    created_at = models.DateTimeField(auto_now_add=True)

class Comment(models.Model):
    post = models.ForeignKey(Post, on_delete=models.CASCADE, related_name='comments')
    author_name = models.CharField(max_length=100)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)

def run():
    author = Author.objects.create(name='Tech Writer')
    category = Category.objects.create(name='Programming')
    tag1 = Tag.objects.create(name='python')
    tag2 = Tag.objects.create(name='django')

    post1 = Post.objects.create(title='Python Basics', content='Learning Python', author=author, category=category)
    post1.tags.add(tag1, tag2)

    post2 = Post.objects.create(title='Django Advanced', content='Advanced Django', author=author, category=category)
    post2.tags.add(tag2)

    Comment.objects.bulk_create([
        Comment(post=post1, author_name='Reader1', content='Great post!'),
        Comment(post=post1, author_name='Reader2', content='Very helpful'),
        Comment(post=post2, author_name='Reader3', content='Thanks for sharing'),
    ])

    print('=== Without optimization (multiple database queries) ===')
    posts = Post.objects.all()
    for post in posts:
        # Each access triggers a separate database query
        print(f'{post.title} by {post.author.name} in {post.category.name}')

    print('=== With select_related (single JOIN query) ===')
    posts_optimized = Post.objects.select_related('author', 'category')
    for post in posts_optimized:
        # Author and category data already loaded, no additional queries
        print(f'{post.title} by {post.author.name} in {post.category.name}')

    print('=== With prefetch_related for many-to-many and reverse foreign keys ===')
    posts_with_related = Post.objects.select_related('author', 'category').prefetch_related('tags', 'comments')

    for post in posts_with_related:
        tag_names = ', '.join(tag.name for tag in post.tags.all())
        comment_count = post.comments.count()
        print(f'{post.title} - Tags: {tag_names} - Comments: {comment_count}')

    print('=== Complex prefetch with filtering ===')
    from django.db.models import Prefetch

    # Prefetch only recent comments
    recent_comments = Comment.objects.filter(created_at__gte=timezone.now() - timezone.timedelta(days=7))
    posts_with_recent_comments = Post.objects.prefetch_related(
        Prefetch('comments', queryset=recent_comments, to_attr='recent_comments')
    )

    for post in posts_with_recent_comments:
        print(f'{post.title} has {len(post.recent_comments)} recent comments')"""

[[chapters]]
title = "Indexing"
content = """from django.db import models
from django.utils import timezone

class Author(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField(unique=True)  # Unique constraint creates index automatically
    username = models.CharField(max_length=50, db_index=True)  # Single field index

    def __str__(self):
        return self.name

    class Meta:
        indexes = [
            models.Index(fields=['name']),  # Single field index
            models.Index(fields=['name', 'email']),  # Composite index
            models.Index(fields=['-username']),  # Descending index
        ]

class Post(models.Model):
    title = models.CharField(max_length=200)
    slug = models.SlugField(unique=True)  # Unique creates index
    content = models.TextField()
    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='posts')  # FK creates index
    status = models.CharField(max_length=20, choices=[('draft', 'Draft'), ('published', 'Published')])
    view_count = models.PositiveIntegerField(default=0)
    created_at = models.DateTimeField(default=timezone.now, db_index=True)  # Single field index
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.title

    class Meta:
        indexes = [
            # Composite indexes for common query patterns
            models.Index(fields=['status', 'created_at']),  # Filter by status, order by date
            models.Index(fields=['author', 'status']),      # Posts by author with status
            models.Index(fields=['status', '-view_count']), # Popular published posts
            models.Index(fields=['created_at', 'author']),  # Recent posts by author

            # Partial index (PostgreSQL only) - only index published posts
            models.Index(
                fields=['created_at'],
                condition=models.Q(status='published'),
                name='published_posts_created_idx'
            ),

            # Functional index example (PostgreSQL)
            models.Index(
                models.functions.Upper('title'),
                name='post_title_upper_idx'
            ),
        ]

class Comment(models.Model):
    post = models.ForeignKey(Post, on_delete=models.CASCADE, related_name='comments')
    author_email = models.EmailField()
    content = models.TextField()
    created_at = models.DateTimeField(default=timezone.now)
    is_approved = models.BooleanField(default=False)

    class Meta:
        indexes = [
            # Index for filtering approved comments by post
            models.Index(fields=['post', 'is_approved', 'created_at']),
            # Index for finding comments by email
            models.Index(fields=['author_email']),
        ]

def run():
    # Create test data
    author = Author.objects.create(
        name='Performance Tester',
        email='perf@example.com',
        username='perftest'
    )

    # Create posts with various statuses and dates
    posts_data = [
        {'title': 'Recent Published', 'slug': 'recent-published', 'status': 'published', 'view_count': 100},
        {'title': 'Old Published', 'slug': 'old-published', 'status': 'published', 'view_count': 500},
        {'title': 'Recent Draft', 'slug': 'recent-draft', 'status': 'draft', 'view_count': 0},
        {'title': 'Popular Post', 'slug': 'popular-post', 'status': 'published', 'view_count': 1000},
    ]

    for i, post_data in enumerate(posts_data):
        post = Post.objects.create(
            title=post_data['title'],
            slug=post_data['slug'],
            content='Sample content for performance testing',
            author=author,
            status=post_data['status'],
            view_count=post_data['view_count']
        )

        # Make some posts older
        if 'Old' in post_data['title']:
            post.created_at = timezone.now() - timezone.timedelta(days=30)
            post.save()

    print('=== Queries that benefit from indexes ===')

    # These queries will use the indexes we defined

    # 1. Query using author username index
    author_by_username = Author.objects.filter(username='perftest').first()
    print(f'Found author by username: {author_by_username.name}')

    # 2. Query using composite index (status + created_at)
    recent_published = Post.objects.filter(
        status='published',
        created_at__gte=timezone.now() - timezone.timedelta(days=7)
    ).order_by('-created_at')
    print(f'Recent published posts: {recent_published.count()}')

    # 3. Query using author + status index
    author_posts = Post.objects.filter(author=author, status='published')
    print(f'Published posts by author: {author_posts.count()}')

    # 4. Query using status + view_count index
    popular_posts = Post.objects.filter(status='published').order_by('-view_count')[:2]
    print('Top popular posts:')
    for post in popular_posts:
        print(f'- {post.title}')

    # 5. Query using created_at index
    all_recent = Post.objects.filter(created_at__gte=timezone.now() - timezone.timedelta(days=1))
    print(f'All recent posts: {all_recent.count()}')
"""