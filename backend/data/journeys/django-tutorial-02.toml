title = "Django Tutorial - 02"
order = 2

[[chapters]]
title = "Creating models"
content = """
# The content of this snippet is extracted from the Django documentation:
# https://docs.djangoproject.com/en/5.2/intro/tutorial02/

from django.db import models


class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField("date published")


class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
"""

[[chapters]]
title = "Playing with the API [1]"
content = """
# The content of this snippet is extracted from the Django documentation:
# https://docs.djangoproject.com/en/5.2/intro/tutorial02/

from django.db import models


class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField("date published")


class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)

def run():
    # No questions are in the system yet.
    print(Question.objects.all())
    # => <QuerySet []>

    # Create a new Question.
    # Support for time zones is enabled in the default settings file, so
    # Django expects a datetime with tzinfo for pub_date. Use timezone.now()
    # instead of datetime.datetime.now() and it will do the right thing.
    from django.utils import timezone
    q = Question(question_text="What's new?", pub_date=timezone.now())

    # Save the object into the database. You have to call save() explicitly.
    q.save()

    # Now it has an ID.
    print(q.id)
    # => 1

    # Access model field values via Python attributes.
    print(q.question_text)
    # => "What's new?"
    print(q.pub_date)
    # => datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=datetime.timezone.utc)

    # Change values by changing the attributes, then calling save().
    q.question_text = "What's up?"
    q.save()

    # objects.all() displays all the questions in the database.
    print(Question.objects.all())
    # => <QuerySet [<Question: Question object (1)>]>
"""


[[chapters]]
title = "Playing with the API [2]"
content = """
# The content of this snippet is extracted from the Django documentation:
# https://docs.djangoproject.com/en/5.2/intro/tutorial02/

import datetime

from django.db import models
from django.utils import timezone


class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField("date published")

    def __str__(self):
        return self.question_text

    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)


class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)

    def __str__(self):
        return self.choice_text


def run():
    # Create a new Question.
    q = Question.objects.create(
        question_text="What's new?",
        pub_date=timezone.now()
    )

    # Make sure our __str__() addition worked.
    print(Question.objects.all())
    # => <QuerySet [<Question: What's up?>]>

    # Django provides a rich database lookup API that's entirely driven by
    # keyword arguments.
    print(Question.objects.filter(id=1))
    # => <QuerySet [<Question: What's up?>]>
    print(Question.objects.filter(question_text__startswith="What"))
    # => <QuerySet [<Question: What's up?>]>

    # Get the question that was published this year.
    current_year = timezone.now().year
    print(Question.objects.get(pub_date__year=current_year))
    # => <Question: What's up?>

    # Request an ID that doesn't exist, this will raise an exception.
    try: 
        print(Question.objects.get(id=2))
    except Question.DoesNotExist as e:
        print(e)
        # => Question matching query does not exist.

    # Lookup by a primary key is the most common case, so Django provides a
    # shortcut for primary-key exact lookups.
    # The following is identical to Question.objects.get(id=1).
    print(Question.objects.get(pk=1))
    # => <Question: What's up?>

    # Make sure our custom method worked.
    q = Question.objects.get(pk=1)
    print(q.was_published_recently())
    # => True

    # Give the Question a couple of Choices. The create call constructs a new
    # Choice object, does the INSERT statement, adds the choice to the set
    # of available choices and returns the new Choice object. Django creates
    # a set (defined as "choice_set") to hold the "other side" of a ForeignKey
    # relation (e.g. a question's choice) which can be accessed via the API.
    q = Question.objects.get(pk=1)

    # Display any choices from the related object set -- none so far.
    print(q.choice_set.all())
    # => <QuerySet []>

    # Create three choices.
    q.choice_set.create(choice_text="Not much", votes=0)
    # => <Choice: Not much>
    q.choice_set.create(choice_text="The sky", votes=0)
    # => <Choice: The sky>
    c = q.choice_set.create(choice_text="Just hacking again", votes=0)

    # Choice objects have API access to their related Question objects.
    print(c.question)
    # => <Question: What's up?>

    # And vice versa: Question objects get access to Choice objects.
    print(q.choice_set.all())
    # => <QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>
    print(q.choice_set.count())
    # => 3

    # The API automatically follows relationships as far as you need.
    # Use double underscores to separate relationships.
    # This works as many levels deep as you want; there's no limit.
    # Find all Choices for any question whose pub_date is in this year
    # (reusing the 'current_year' variable we created above).
    print(Choice.objects.filter(question__pub_date__year=current_year))
    # => <QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>

    # Let's delete one of the choices. Use delete() for that.
    c = q.choice_set.filter(choice_text__startswith="Just hacking")
    c.delete()
"""
